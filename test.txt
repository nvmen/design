@Service
public class TokenValidationService implements JwtDecoder {

    private final JwtDecoder jwtDecoder;

    @Autowired
    public TokenValidationService(@Value("${azure.activedirectory.client-id}") String clientId,
                                  @Value("${azure.activedirectory.authority}") String authority) {
        String openIdConfigUrl = String.format("%s/.well-known/openid-configuration", authority);
        HttpClient httpClient = HttpClient.newBuilder().build();
        HttpRequest httpRequest = HttpRequest.newBuilder()
                .uri(URI.create(openIdConfigUrl))
                .GET()
                .build();

        try {
            HttpResponse<String> httpResponse = httpClient.send(httpRequest, HttpResponse.BodyHandlers.ofString());
            String openIdConfigJson = httpResponse.body();

            Map<String, Object> openIdConfigMap = new ObjectMapper().readValue(openIdConfigJson, new TypeReference<Map<String, Object>>() {});
            String jwksUri = (String) openIdConfigMap.get("jwks_uri");
            String idTokenSigningAlg = (String) openIdConfigMap.get("id_token_signing_alg_values_supported").toString().replaceAll("\\[", "").replaceAll("\\]", "");

            IClientCredential credential = ClientCredentialFactory.createFromSecret(clientSecret);
            ConfidentialClientApplication cca = ConfidentialClientApplication.builder(clientId, credential)
                    .authority(authority)
                    .build();

            this.jwtDecoder = NimbusJwtDecoder.withJwkSetUri(jwksUri)
                    .jwsAlgorithm(SignatureAlgorithm.parse(idTokenSigningAlg))
                    .build();
        } catch (Exception e) {
            throw new RuntimeException("Error retrieving OpenID configuration", e);
        }
    }

    @Override
    public Jwt decode(String token) throws JwtException {
        return this.jwtDecoder.decode(token);
    }
}


@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class SecurityConfig extends AADResourceServerWebSecurityConfigurerAdapter {

    @Autowired
    private TokenValidationService tokenValidationService;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        super.configure(http);

        http.authorizeRequests()
            .antMatchers("/api/**")
            .authenticated()
            .and()
            .oauth2ResourceServer()
            .jwt()
            .decoder(this.tokenValidationService);
    }
}


@Service
public class TokenValidationService implements JwtDecoder {

    private final JwtDecoder jwtDecoder;

    @Autowired
    public TokenValidationService(@Value("${azure.activedirectory.client-id}") String clientId,
                                  @Value("${azure.activedirectory.authority}") String authority) {

        IPublicClientApplication pca = PublicClientApplication.builder(clientId)
                .authority(authority)
                .build();

        this.jwtDecoder = NimbusJwtDecoder.withJwkSetUri(pca.getOpenIdConfiguration().getJwksUri()).build();
    }

    @Override
    public Jwt decode(String token) throws JwtException {
        return this.jwtDecoder.decode(token);
    }
}



@Service
public class TokenValidationService implements JwtDecoder {

    private final JwtDecoder jwtDecoder;

    @Autowired
    public TokenValidationService(@Value("${azure.activedirectory.client-id}") String clientId,
                                  @Value("${azure.activedirectory.authority}") String authority) {

        String openIdConfigUrl = String.format("%s/.well-known/openid-configuration", authority);
        HttpClient httpClient = HttpClient.newBuilder().build();
        HttpRequest httpRequest = HttpRequest.newBuilder()
                .uri(URI.create(openIdConfigUrl))
                .GET()
                .build();

        try {
            HttpResponse<String> httpResponse = httpClient.send(httpRequest, HttpResponse.BodyHandlers.ofString());
            String openIdConfigJson = httpResponse.body();

            OpenIdConfiguration openIdConfig = JsonHelper.convertJsonToObject(openIdConfigJson, OpenIdConfiguration.class);

            IClientCredential credential = ClientCredentialFactory.createFromSecret(clientSecret);
            ConfidentialClientApplication cca = ConfidentialClientApplication.builder(clientId, credential)
                    .authority(authority)
                    .build();

            this.jwtDecoder = NimbusJwtDecoder.withJwkSetUri(openIdConfig.getJwksUri())
                    .jwsAlgorithm(SignatureAlgorithm.parse(openIdConfig.getIdTokenSigningAlg()))
                    .build();
        } catch (Exception e) {
            throw new RuntimeException("Error retrieving OpenID configuration", e);
        }
    }

    @Override
    public Jwt decode(String token) throws JwtException {
        return this.jwtDecoder.decode(token);
    }
}

===================================================================





// https://mvnrepository.com/artifact/com.azure/azure-core
implementation 'com.azure:azure-core:1.38.0'



// https://mvnrepository.com/artifact/com.fasterxml.woodstox/woodstox-core
implementation 'com.fasterxml.woodstox:woodstox-core:6.5.1'
// https://mvnrepository.com/artifact/org.springframework.security/spring-security-oauth2-client
implementation 'org.springframework.security:spring-security-oauth2-client:6.0.3'


https://github.com/Azure-Samples/ms-identity-java-webapi/tree/edbd399155341556e3871065d1b8b4be2e9cbce0/msal-obo-sample/src/main/java/com/microsoft/azure/msalobosample
// https://mvnrepository.com/artifact/org.springframework.security/spring-security-jwt
implementation 'org.springframework.security:spring-security-jwt:1.0.5.RELEASE'

// https://mvnrepository.com/artifact/org.springframework.security.oauth/spring-security-oauth2
implementation 'org.springframework.security.oauth:spring-security-oauth2:2.4.2.RELEASE'



dependencies {
	compile "com.microsoft.azure:msal4j:0.5.0-preview"
	compile "com.nimbusds:oauth2-oidc-sdk:6.5"
	compile "org.json:json:20090211"
	compile "org.projectlombok:lombok:*"
	compile "org.springframework.boot:spring-boot-starter-thymeleaf:*"
	compile "org.springframework.boot:spring-boot-starter-web:*"
	testCompile "org.springframework.boot:spring-boot-starter-test:*"
	compile "org.springframework.security.oauth:spring-security-oauth2:2.3.6.RELEASE"
	compile "org.springframework.security:spring-security-jwt:1.0.10.RELEASE"
	compile "org.springframework.boot:spring-boot-starter-cache:*"
	compile "com.google.guava:guava:20.0"
}



@Configuration
@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

  @Override
  protected void configure(HttpSecurity http) throws Exception {
    http
      .cors()
      .and()
      // other security configurations
  }

  @Bean
  public CorsConfigurationSource corsConfigurationSource() {
    CorsConfiguration configuration = new CorsConfiguration();
    configuration.setAllowedOrigins(Arrays.asList("*"));
    configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE"));
    configuration.setAllowedHeaders(Arrays.asList("Authorization", "Content-Type"));

    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    source.registerCorsConfiguration("/**", configuration);

    return source;
  }
}
In the configure method, you can call the cors() method to enable CORS support. This will add a CorsFilter to the Spring Security filter chain, which will intercept incoming requests and handle CORS headers.

Then, you can define a CorsConfigurationSource bean to configure the allowed origins, methods, and headers. In this example, we allow requests from any origin (*), and support GET, POST, PUT, and DELETE methods. We also allow the Authorization and Content-Type headers.

Finally, we register the CorsConfiguration with the UrlBasedCorsConfigurationSource, and return the source bean.

Note that this example allows requests from any origin, which may not be secure in some cases. You should modify the allowed origins based on your specific requirements.




import AxiosInstance from '../../utils/config/axiosInterceptor';

export abstract class GenericService {
  protected apiRootURL: string;
  protected axiosInstance;

  protected constructor() {
    this.apiRootURL = process.env.NEXT_PUBLIC_API_URL || '';
    this.axiosInstance = AxiosInstance;
  }

  /**
   * get from url
   * @param apiUrl
   */
  get<T>(apiUrl: string): Promise<T> {
    const url = this.apiRootURL + apiUrl;
    return this.axiosInstance.get(url).then((response) => {
      return <T>response.data;
    });
  }

  /**
   * base post method
   * @param apiUrl
   * @param body
   */
  post<T>(apiUrl: string, body: Object): Promise<T> {
    const url = this.apiRootURL + apiUrl;
    return this.axiosInstance.post(url, body).then((response) => {
      return <T>response.data;
    });
  }

  /**
   * get back end url with base route
   * @param url
   */
  getBackendUrl(url: string) {
    return this.apiRootURL + url;
  }
}


  static getInstance() {
    if (OnBoardingService.serviceInstance === null) {
      OnBoardingService.serviceInstance = new OnBoardingService();
    }
    return this.serviceInstance;
  }


https://github.com/jasonshave/JavaClientCredentialFlowWebAPI/blob/master/serverprototype/src/main/java/com/microsoft/javamanagedidentitywebapi/serverprototype/SecurityConfiguration.java


azure:
  activedirectory:
    tenant-id: <your-tenant-id>
    client-id: <your-client-id>
    client-secret: <your-client-secret>
    authorization-uri: https://login.microsoftonline.com/<your-tenant-id>/oauth2/v2.0/authorize
    token-uri: https://login.microsoftonline.com/<your-tenant-id>/oauth2/v2.0/token
    user-info-uri: https://graph.microsoft.com/v1.0/me/


// https://mvnrepository.com/artifact/com.microsoft.azure/azure-active-directory-spring-boot-starter
implementation("com.microsoft.azure:azure-active-directory-spring-boot-starter:3.0.0")

implementation 'org.springframework.boot:spring-boot-starter-oauth2-resource-server:3.0.6'

// https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-oauth2-resource-server
implementation group: 'org.springframework.boot', name: 'spring-boot-starter-oauth2-resource-server', version: '3.0.6'

https://github.com/Azure-Samples/ms-identity-java-spring-tutorial/blob/main/3-Authorization-II/protect-web-api/resource-api/src/main/java/com/microsoft/azuresamples/msal4j/msidentityspringbootwebapi/SecurityConfig.java

// https://mvnrepository.com/artifact/com.azure/azure-core
implementation group: 'com.azure', name: 'azure-core', version: '1.38.0'
https://github.com/AzureAD/microsoft-authentication-library-for-java

implementation group: 'org.springframework.boot', name: 'spring-boot-starter-security', version: '3.0.6'

https://github.com/Azure-Samples/ms-identity-java-webapi/blob/edbd399155341556e3871065d1b8b4be2e9cbce0/msal-obo-sample/src/main/resources/application.properties

// https://mvnrepository.com/artifact/com.nimbusds/oauth2-oidc-sdk
runtimeOnly 'com.nimbusds:oauth2-oidc-sdk:10.8'

